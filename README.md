# engine-bench
[![CI (Coq)](https://github.com/mit-plv/engine-bench/workflows/CI%20(Coq)/badge.svg?branch=master)](https://github.com/mit-plv/engine-bench/actions?query=workflow%3A%22CI+%28Coq%29%22+branch%3Amaster) [![CI (LaTeX)](https://github.com/mit-plv/engine-bench/workflows/CI%20(LaTeX)/badge.svg?branch=master)](https://github.com/mit-plv/engine-bench/actions?query=workflow%3A%22CI+%28LaTeX%29%22+branch%3Amaster)

Benchmarks for various proof engines

# Performance Graphs
## Coq
Some autogenerated performance graphs for Coq are available at [here](https://mit-plv.github.io/engine-bench/coq.pdf).

# Some Information About Benchmarks:
Assumption: Proof engine API has partial (proof) terms, and is modular
- Tactics should reference quantified assumptions in the same way they reference global constants

Performance Criterion: Adding a new let binder underneath n lets should be Õ(1)
- Coq: See [`coq/PerformanceDemos/do_n_let_binder.v`](./coq/PerformanceDemos/do_n_let_binder.v), [`coq/PerformanceExperiments/intros_n_let.v`](./coq/PerformanceExperiments/intros_n_let.v), [`coq/PerformanceExperiments/do_n_pose.v`](./coq/PerformanceExperiments/do_n_pose.v), [`coq/PerformanceExperiments/let_n_uconstr.v`](./coq/PerformanceExperiments/let_n_uconstr.v), and [`coq/PerformanceExperiments/let_n_ltac2.v`](./coq/PerformanceExperiments/let_n_ltac2.v)

  intros_n_let | do_n_pose | let_n_uconstr | let_n_ltac2
  --|--|--|--
  <img src="https://mit-plv.github.io/engine-bench/coq/intros-n-let.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/do-n-pose.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/let-n-uconstr.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/let-n-ltac2.svg" height=100px />


Performance Criterion: Adding a new binder underneath n binders should be Õ(1)
- Coq: See [`coq/PerformanceDemos/do_n_binder.v`](./coq/PerformanceDemos/do_n_binder.v), [`coq/PerformanceExperiments/intros_n_fun.v`](./coq/PerformanceExperiments/intros_n_fun.v), [`coq/PerformanceExperiments/fun_n_uconstr.v`](./coq/PerformanceExperiments/fun_n_uconstr.v), and [`coq/PerformanceExperiments/fun_n_ltac2.v`](./coq/PerformanceExperiments/fun_n_ltac2.v)

  intros_n_fun | fun_n_uconstr | fun_n_ltac2
  --|--|--
  <img src="https://mit-plv.github.io/engine-bench/coq/intros-n-fun.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/fun-n-uconstr.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/fun-n-ltac2.svg" height=100px />

- Needed for: good performance of rewrite/rewrite_strat under binders
  + Coq: See [`coq/PerformanceDemos/rewrite_strat_under_binders.v`](./coq/PerformanceDemos/rewrite_strat_under_binders.v), [`coq/PerformanceExperiments/repeat_setoid_rewrite_under_binders.v`](./coq/PerformanceExperiments/repeat_setoid_rewrite_under_binders.v), and [`coq/PerformanceExperiments/rewrite_strat_under_binders.v`](./coq/PerformanceExperiments/rewrite_strat_under_binders.v)

    repeat_setoid_rewrite_under_binders | rewrite_strat_under_binders
    --|--
    <img src="https://mit-plv.github.io/engine-bench/coq/repeat-setoid-rewrite-under-binders.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/rewrite-strat-under-binders.svg" height=100px />

- Needed for: good performance of proving large conjunctions without structural types
  + Coq: See [`coq/PerformanceDemos/repeated_conj.v`](./coq/PerformanceDemos/repeated_conj.v), [`coq/PerformanceExperiments/conj_True_repeat_constructor.v`](./coq/PerformanceExperiments/conj_True_repeat_constructor.v), and [`coq/PerformanceExperiments/conj_True_fast_conj.v`](./coq/PerformanceExperiments/conj_True_fast_conj.v)

    conj_True_repeat_constructor | conj_True_fast_conj
    --|--
    <img src="https://mit-plv.github.io/engine-bench/coq/conj-True-repeat-constructor.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/conj-True-fast-conj.svg" height=100px />

- Needed for: good performance of turning `f (f (... (f x))) = g (g (... (g x)))` given `f x = g x` (or `x = y -> f x = g y`) w/ `rewrite_strat`
  + Coq: See [`coq/PerformanceDemos/rewrite_strat_repeated_app.v`](./coq/PerformanceDemos/rewrite_strat_repeated_app.v), [`coq/PerformanceExperiments/rewrite_repeated_app_autorewrite.v`](./coq/PerformanceExperiments/rewrite_repeated_app_autorewrite.v), [`coq/PerformanceExperiments/rewrite_repeated_app_ssrrewrite.v`](./coq/PerformanceExperiments/rewrite_repeated_app_ssrrewrite.v), [`coq/PerformanceExperiments/rewrite_repeated_app_rewrite_strat.v`](./coq/PerformanceExperiments/rewrite_repeated_app_rewrite_strat.v), and [`coq/PerformanceExperiments/rewrite_repeated_app_fast_rewrite.v`](./coq/PerformanceExperiments/rewrite_repeated_app_fast_rewrite.v)

    rewrite_repeated_app_autorewrite | rewrite_repeated_app_ssrrewrite | rewrite_repeated_app_rewrite_strat | rewrite_repeated_app_fast_rewrite
    --|--|--|--
    <img src="https://mit-plv.github.io/engine-bench/coq/rewrite-repeated-app-autorewrite.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/rewrite-repeated-app-ssrrewrite.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/rewrite-repeated-app-rewrite-strat.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/rewrite-repeated-app-fast-rewrite.svg" height=100px />

Performance criterion (convenient, not limiting): Typechecking an application of a function to n arguments with no conversion should be Õ(n)
- Can be constructed if you can prove conjunction/pairing without quadratic overhead
- Coq: See [`coq/PerformanceDemos/app_n.v`](./coq/PerformanceDemos/app_n.v), [`coq/PerformanceExperiments/app_n_uconstr.v`](./coq/PerformanceExperiments/app_n_uconstr.v), and [`coq/PerformanceExperiments/app_n_ltac2.v`](./coq/PerformanceExperiments/app_n_ltac2.v)

  app_n_uconstr | app_n_ltac2
  --|--
  <img src="https://mit-plv.github.io/engine-bench/coq/app-n-uconstr.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/app-n-ltac2.svg" height=100px />

Note: not talk about display names at all; if you want to have them, all operations need to be basically Õ(1)

Performance Criterion: fast alpha-equivalence check (Õ(term size))
- we might also want alpha-variation as a fast primitive (even if the original term took arbitraily long to typecheck)
- Coq: See [`coq/PerformanceDemos/constr_eq.v`](./coq/PerformanceDemos/constr_eq.v) and [`coq/PerformanceExperiments/constr_eq_alpha.v`](./coq/PerformanceExperiments/constr_eq_alpha.v)

  constr_eq_alpha |
  --|
  <img src="https://mit-plv.github.io/engine-bench/coq/constr-eq-alpha.svg" height=100px /> |


Unification problem (context changing):
- `eq_refl : (fun y => y) = ((fun e y => e y) ?e)`
- `eq_refl : (fun y => y) = (fun y => ?e@{no y} y)`
- User: inside ?e, do intro, i.e., `?e@{no y} := fun z => ?e2@{z}`
- `eq_refl : (fun y => y) = (fun y => (fun z => ?e2@{z, no y}) y)`

Performance Criterion: lifting identity evar substitution should Õ(1)
- Coq: See [`coq/PerformanceDemos/lift_identity_evar_subst.v`](./coq/PerformanceDemos/lift_identity_evar_subst.v), [`coq/PerformanceExperiments/lift_identity_evar_subst_nevars.v`](./coq/PerformanceExperiments/lift_identity_evar_subst_nevars.v), [`coq/PerformanceExperiments/lift_identity_evar_subst_ctx.v`](./coq/PerformanceExperiments/lift_identity_evar_subst_ctx.v), and [`coq/PerformanceExperiments/lift_identity_evar_subst_binders.v`](./coq/PerformanceExperiments/lift_identity_evar_subst_binders.v)

  lift_identity_evar_subst_nevars | lift_identity_evar_subst_ctx | lift_identity_evar_subst_binders
  --|--|--
  <img src="https://mit-plv.github.io/engine-bench/coq/lift-identity-evar-subst-nevars.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/lift-identity-evar-subst-ctx.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/lift-identity-evar-subst-binders.svg" height=100px />


Performance Criterion: composing identity evar substitution should Õ(1)
- Needed for: modular performance behavior

Performance Criterion: lifting non-identity evar substitution should Õ(size of subst)
- Coq: See [`coq/PerformanceDemos/lift_non_identity_evar_subst.v`](./coq/PerformanceDemos/lift_non_identity_evar_subst.v), [`coq/PerformanceExperiments/lift_non_identity_evar_subst_nevars.v`](./coq/PerformanceExperiments/lift_non_identity_evar_subst_nevars.v), [`coq/PerformanceExperiments/lift_non_identity_evar_subst_ctx.v`](./coq/PerformanceExperiments/lift_non_identity_evar_subst_ctx.v), and [`coq/PerformanceExperiments/lift_non_identity_evar_subst_binders.v`](./coq/PerformanceExperiments/lift_non_identity_evar_subst_binders.v)

  lift_non_identity_evar_subst_nevars | lift_non_identity_evar_subst_ctx | lift_non_identity_evar_subst_binders
  --|--|--
  <img src="https://mit-plv.github.io/engine-bench/coq/lift-non-identity-evar-subst-nevars.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/lift-non-identity-evar-subst-ctx.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/lift-non-identity-evar-subst-binders.svg" height=100px />


Performance Criterion: composing non-identity evar substitution should Õ(size of subst)


Performance Criterion: Evar creation should be Õ(1)
- Coq: See [`coq/PerformanceExperiments/do_n_open_constr_True.v`](./coq/PerformanceExperiments/do_n_open_constr_True.v)

  do_n_open_constr_True |
  --|
  <img src="https://mit-plv.github.io/engine-bench/coq/do-n-open-constr-True.svg" height=100px /> |

Performance Criteria:
 - 1-step delta on k constants should Õ(output term size)
 - 1-step iota should be Õ(output term size)
 - 1-step beta on k arguments of the same application node where each argument is mentioned multiple times should be Õ(input term size + output term size)
 - Coq: See [`coq/PerformanceDemos/one_step_reduction.v`](./coq/PerformanceDemos/one_step_reduction.v), [`coq/PerformanceExperiments/one_step_reduction.v`](./coq/PerformanceExperiments/one_step_reduction.v), and [`coq/PerformanceExperiments/one_step_reduction_with_abstract.v`](./coq/PerformanceExperiments/one_step_reduction_with_abstract.v)

  one_step_reduction | one_step_reduction_with_abstract
  --|--
  <img src="https://mit-plv.github.io/engine-bench/coq/one-step-reduction.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/one-step-reduction-with-abstract.svg" height=100px />


Performance Criterion: Inserting a cast node should be Õ(conversion checking the types)


Performance Criterion: Full reduction on a function of complexity O(f) should be Õ(f + input term size + output term size)
- See [`coq/PerformanceDemos/quadratic_reduction.v`](./coq/PerformanceDemos/quadratic_reduction.v), [`coq/PerformanceExperiments/quadratic_cbv_lazy_PHOAS.v`](./coq/PerformanceExperiments/quadratic_cbv_lazy_PHOAS.v), [`coq/PerformanceExperiments/quadratic_native_PHOAS.v`](./coq/PerformanceExperiments/quadratic_native_PHOAS.v), and [`coq/PerformanceExperiments/quadratic_vm_PHOAS.v`](./coq/PerformanceExperiments/quadratic_vm_PHOAS.v)

  quadratic_cbv_lazy_PHOAS | quadratic_native_PHOAS | quadratic_vm_PHOAS
  --|--|--
  <img src="https://mit-plv.github.io/engine-bench/coq/quadratic-cbv-lazy-PHOAS.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/quadratic-native-PHOAS.svg" height=100px /> | <img src="https://mit-plv.github.io/engine-bench/coq/quadratic-vm-PHOAS.svg" height=100px />


Performance Criterion: lifting term across n consecutive binders should be Õ(term size)
- maybe we should require this to be O(1) so we don't have to batch lifting?

Performance Criterion: substitution-of-variables-for-variables should be Õ(term size)
- TODO: This can maybe be subsumed into beta?

Performance Criterion: pattern on k variables should be Õ(term size + k + cost of retypechecking the output term (only if input term is not simply typed))
- Coq: See [`coq/PerformanceDemos/pattern.v`](./coq/PerformanceDemos/pattern.v) and [`coq/PerformanceExperiments/pattern.v`](./coq/PerformanceExperiments/pattern.v)

  pattern |
  --|
  <img src="https://mit-plv.github.io/engine-bench/coq/pattern.svg" height=100px /> |


Performance Criterion: pattern should be Õ(term size * size of thing being patterned + cost of retypechecking the output term (only if input term is not simply typed))
- Note: Andres is not confident in this
- Coq: See [`coq/PerformanceDemos/pattern.v`](./coq/PerformanceDemos/pattern.v) and [`coq/PerformanceExperiments/pattern.v`](./coq/PerformanceExperiments/pattern.v)

  pattern |
  --|
  <img src="https://mit-plv.github.io/engine-bench/coq/pattern.svg" height=100px /> |


```
x, y := x |- pattern x in (eq_refl x : x = y)

x, z, pf : x = z, y := x |- subst x in (eq_refl x : x = y)
eq_rect ?P pf (?goal : eq_refl z : z = y <-- ill typed) : (eq_refl x : x = y)
```
What's `?P`?

Andres: let's postpone pattern discussion
- in particular perhaps pattern shouldn't be a primitive because it does too much?

later:
- pattern-without-conversion should be fast
- pattern-with-conversion should be as slow as needed (because of conversion during typechecking) but not gratuitously slow
- neither needs to be a primitive operation.

Backtracking???? maybe discuss that this is really about functional interface / persistence, and the cost of providing that
- (How do you implement progress without backtracking)

----------

Tactics for the paper:

- `pattern`
- `destruct` / `induction`
- `assert`
- `rewrite`
- `setoid_rewrite` (rewrite with binders)
- `autorewrite`
- `rewrite_strat` / `autosetoid_rewrite`
- `intro` / `intros` / `revert` / `generalize` / `set` / `clear` / `clearbody`
- `refine` / `exact` / `assumption`
- `change` / `refine` + unification
- `unify`, roughly how an unuification algorithm can do its job by calling intantiate / refine-in-evar / reduction-step-with/in-evar
- `constr:(⋯)` / `open_constr:(⋯)`
- `match goal` / `match` constr (readback problem)
- moving constrs / out-of-band-things across contexts?
- 1-step-reduction / multi-step-reduction / `cbv` / `lazy` / `vm_compute` / ⋯ (probably not much detail, either use the steps above or use a skyhook vm)
- `pose` / `pose proof`
- run tactic under binders (i.e., readback under binders)
- `lia` by simplex by `pose`? or perhaps `congruence`? (analyze performance overhead over just doing the computation)
- non-reflective `ring` tactic? try to estaiblish correspondance between time spent in a reflective and in a non-reflective implementation, to show that our proof engine can do okay on things previously pushed to reflection
- `apply` (`rapply`!) / `apply ⋯ in ⋯` / `auto`


there are "goal management" tactics like `clear` / `cycle` / `shelve` that seem totally orthogonoal to everything here

also let's pretend multisuccess doesn't exist



only multi-goal thing: yes you can do things in any evar.

how do we transfer `constr`-s between evars?

# Miscellaneous Text

Here is some text associated with this project that seems worth recording, that hasn't found a better home yet.

## Signal Conversion between Andres and Jason on 2020-05-24

Andres (Sun 5:48pm): why do you think one-step reductions do not make sense to bench?

Jason (Sun 6:03pm): Ultimately it's because Coq doesn't expose a satisfactory one-step reduction.  (But maybe you claim the thing to do is to just bench the version that we can hack up in Coq, even when we know most of the time isn't spent in the single step of reduction?)  I think it's hard to construct them in a way where you're actually benching the single step.  If we do it via Ltac match + constr hacks, I expect we incur overhead in retypechecking and Ltac matching (I suppose I might be wrong, but we'd have to be dealing with truly enormous terms before we expect one-step reduction to take more than 0.0004 seconds (Coq can only measure down to 0.001).  Alternatively, we could do a non-one-step reduction when there's only one step to do, but it's not clear to me to what extent this is benching what we want to bench.  Alternatively we could try to bench a conversion problem where there's just one step of reduction to do, but again I think we'll end up just measuring the conversation overhead

Andres (Sun 6:05pm): please save this explanation somewhere

in that case I have nothing to add

(I don't understand when substitutions are composed)

Jason (Sun 6:06pm): I guess alternatively we could write our own single-step reduction primitive in Ltac2 (in which case I expect we incur the 100x--300x overhead of Ltac2 being interpreted) or as an OCaml plugin, and bench these

Maybe we should do this?

I could code up tests for this

> (I don't understand when substitutions are composed)

Yeah, this one is fuzzy in my head too.  I think this might involve benching Optimize Proof as a function of the number of nested evars?

Andres (Sun 6:09pm): ltac2 calling something like `unsafe_change`?

or just returning terms without establishing conversion? that would be too easy


> Yeah, this one is fuzzy in my head too.  I think this might involve benching Optimize Proof as a function of the number of nested evars?

in that case, perhaps we should try to define our performance criteria without talking about substitutions?

Jason (Sun 6:11pm):

> or just returning terms without establishing conversion? that would be too easy

Yeah, just returning the term without establishing conversion.  We can separately bench the conversation problem if you want (benching the one-step conversion problem is actually quite easy, though I expect the times to be quite sensitive to the size of the rest of the term, etc).  It's figuring out how to bench the computation of the reduced term without benching anything else that's hard.

> in that case, perhaps we should try to define our performance criteria without talking about substitutions?

No, composition of substitutions is needed to instantiate evars with other evars

Andres (Sun 6:13pm): . yeah if we ever end up losing it in a table we should show both parts

> No, composition of substitutions is needed to instantiate evars with other evars

so define the desired performance of instantiating one evar with another :P

Jason (Sun 6:14pm): It's just that Coq is very lazy about when it does the actual substitutions, and I'm not very familiar with this part of the machinery.  It used to happen on every single tactic invocation, and this is what made `cbv beta` in a small goal take a long time depending on how big the context was


> so define the desired performance of instantiating one evar with another :P

Sure, we could do that.  I'm not sure how to bench it though.  In particular, I'm not sure how to define it precisely and know what the relevant axes are (one evar with another when they're in the same context?  Or different ones?)

Andres (Sun 6:17pm): that story might be worth telling

my proof engine would do log of scope depth difference, though of course that's without counting catching up on new beta reduction opportunities

I don't have any idea what coq does
